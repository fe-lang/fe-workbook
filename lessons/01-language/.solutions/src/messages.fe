struct Store {
    value: u256,
}

use std::evm::{Call, Evm}
use std::evm::effects::assert

msg CounterMsg {
    #[selector = 0x00000001]
    Inc { by: u256 },

    #[selector = 0x00000002]
    Get {} -> u256,

    #[selector = 0x00000003]
    Reset {},
}

msg AdminMsg {
    // Pick any unused 4-byte value; it just must be unique for this contract.
    #[selector = 0x00000004]
    Nuke {},
}

pub contract Counter {
    mut store: Store

    init() uses (mut store) {
        store.value = 0
    }

    recv CounterMsg {
        Inc { by } uses (mut store) {
            store.value = store.value + by
        }

        Get {} -> u256 uses (store) {
            store.value
        }

        Reset {} uses (mut store) {
            store.value = 0
        }
    }

    recv AdminMsg {
        Nuke {} uses (mut store) {
            store.value = 0
        }
    }
}

#[test]
fn test_counter_messages() uses (evm: mut Evm) {
    let addr = evm.create2<Counter>(value: 0, args: (), salt: 0)

    let val: u256 = evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: CounterMsg::Get {}
    )
    assert(val == 0)

    evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: CounterMsg::Inc { by: 2 }
    )

    let val: u256 = evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: CounterMsg::Get {}
    )
    assert(val == 2)

    evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: CounterMsg::Reset {}
    )

    let val: u256 = evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: CounterMsg::Get {}
    )
    assert(val == 0)
}
