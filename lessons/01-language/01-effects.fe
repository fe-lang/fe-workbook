// Effects are explicit capabilities: if a function needs one, it must say so in `uses (...)`.
//
// This file is intentionally broken. Fix it by following the `PROBLEM:` comments.

pub struct Counter { pub value: u256 }

fn inc() uses (counter: mut Counter) {
    counter.value = counter.value + 1
}

fn read() -> u256 uses (counter: Counter) {
    counter.value
}

// PROBLEM: this function mutates `counter` but does not request `counter: mut Counter`.
fn reset() uses (counter: Counter) {
    counter.value = 0
}

// PROBLEM: this function calls effectful functions but declares no effects.
// HINT: it needs (at least) the effects required by `inc()` and `read()`.
fn bump_twice() -> u256 {
    inc()
    inc()
    read()
}

#[test]
fn test_bump_twice() {
    // HINT: make this binding mutable so the `with` block can provide `counter: mut Counter`.
    let counter = Counter { value: 0 }

    with (Counter = counter) {
        // PROBLEM: the `with` block is providing an immutable `Counter` capability.
        let value = bump_twice()
        assert(value == 2)
    }

    // PROBLEM: effects must be contained inside the `with` block.
    reset()
    let value = read()
    assert(value == 1)
}
