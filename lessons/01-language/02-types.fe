trait Double {
    fn double(self) -> Self
}

impl Double for u256 {
    fn double(self) -> Self {
        self + self
    }
}

fn unwrap_or_zero(opt: Option<u256>) -> u256 {
    // PROBLEM: make this match exhaustive.
    // HINT: `Option` has two variants: `Some` and `None`.
    match opt {
        Option::Some(v) => v,
    }
}

fn twice<T>(x: T) -> T {
    // PROBLEM: add the right trait bound to T.
    // HINT: `double()` comes from the `Double` trait.
    // HINT: Constrain `T` to types that implement `Double` (Rust-style `T: Double`).
    // HINT: That way the compiler knows `x.double()` is available.
    x.double()
}

#[test]
fn test_types() {
    let a = unwrap_or_zero(Option::None)
    let b: u256 = twice(21)

    assert(a == 0)
    assert(b == 42)
}
