// This ingot depends on the workspace member `counter`, which is intentionally missing.
//
// The exercise is to create it from the workspace root via:
//   fe new counter
//
// Once the `counter` ingot exists, this test should compile and pass.

use std::abi::sol
use std::evm::{Call, Evm}
use std::evm::effects::assert

use counter::Counter

// Prove the contract type resolves (we don't deploy it here).
fn _typecheck(_: Counter) {}

msg LocalCounterMsg {
    #[selector = sol("increment()")]
    Increment,
    #[selector = sol("get()")]
    Get -> u256,
}

struct LocalCounterStore {
    value: u256,
}

pub contract LocalCounter {
    mut store: LocalCounterStore

    init() uses (mut store) {
        store.value = 0
    }

    recv LocalCounterMsg {
        Increment uses (mut store) {
            store.value = store.value + 1
        }

        Get -> u256 uses (store) {
            store.value
        }
    }
}

#[test]
fn test_local_counter_interaction() uses (evm: mut Evm) {
    let addr = evm.create2<LocalCounter>(value: 0, args: (), salt: 0)
    assert(addr.inner != 0)

    let val: u256 = evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: LocalCounterMsg::Get {}
    )
    assert(val == 0)

    evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: LocalCounterMsg::Increment {}
    )

    evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: LocalCounterMsg::Increment {}
    )

    let val: u256 = evm.call(
        addr: addr,
        gas: 100000,
        value: 0,
        message: LocalCounterMsg::Get {}
    )
    assert(val == 2)
}
