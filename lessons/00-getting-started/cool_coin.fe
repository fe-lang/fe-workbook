use std::evm::{Ctx, Log, StorageMap}
use std::abi::sol

msg Erc20 {
    #[selector = sol("name()")]
    Name -> u256,
    #[selector = sol("symbol()")]
    Symbol -> u256,
    #[selector = sol("decimals()")]
    Decimals -> u8,
    #[selector = sol("totalSupply()")]
    TotalSupply -> u256,
    #[selector = sol("balanceOf(address)")]
    BalanceOf { account: Address } -> u256,
    #[selector = sol("allowance(address,address)")]
    Allowance { owner: Address, spender: Address } -> u256,
    #[selector = sol("transfer(address,uint256)")]
    Transfer { to: Address, amount: u256 } -> bool,
    #[selector = sol("approve(address,uint256)")]
    Approve { spender: Address, amount: u256 } -> bool,
    #[selector = sol("transferFrom(address,address,uint256)")]
    TransferFrom { from: Address, to: Address, amount: u256 } -> bool,
}

msg Erc20Extended {
    #[selector = sol("mint(address,uint256)")]
    Mint { to: Address, amount: u256 } -> bool,
}

struct TokenStore {
    total_supply: u256,
    balances: StorageMap<Address, u256>,
    allowances: StorageMap<(Address, Address), u256>,
}

pub contract CoolCoin uses (ctx: Ctx, log: mut Log) {
    mut store: TokenStore,

    init(initial_supply: u256, owner: Address)
    uses (mut store, mut log)
    {
        if initial_supply > 0 {
            store.total_supply = initial_supply
            store.balances.set(key: owner, value: initial_supply)
            emit_transfer(from: Address::zero(), to: owner, value: initial_supply)
        }
    }

    recv Erc20 {
        Name -> u256 {
            0x436f6f6c436f696e
        }
        Symbol -> u256 {
            0x434f4f4c
        }
        Decimals -> u8 {
            18
        }
        TotalSupply -> u256 uses store {
            store.total_supply
        }
        BalanceOf { account } -> u256 uses store {
            store.balances.get(key: account)
        }
        Allowance { owner, spender } -> u256 uses store {
            store.allowances.get(key: (owner, spender))
        }

        Transfer { to, amount } -> bool uses (mut store, ctx, mut log) {
            let sender = ctx.caller()
            let sender_bal = store.balances.get(key: sender)
            if sender_bal < amount {
                return false
            }
            store.balances.set(key: sender, value: sender_bal - amount)
            store.balances.set(key: to, value: store.balances.get(key: to) + amount)
            emit_transfer(from: sender, to: to, value: amount)
            return true
        }

        Approve { spender, amount } -> bool uses (mut store, ctx, mut log) {
            let sender = ctx.caller()
            store.allowances.set(key: (sender, spender), value: amount)
            emit_approval(owner: sender, spender: spender, value: amount)
            return true
        }

        TransferFrom { from, to, amount } -> bool
        uses (mut store, ctx, mut log)
        {
            let spender = ctx.caller()
            let allowed = store.allowances.get(key: (from, spender))
            if allowed < amount {
                return false
            }
            let from_bal = store.balances.get(key: from)
            if from_bal < amount {
                return false
            }
            store.allowances.set(key: (from, spender), value: allowed - amount)
            store.balances.set(key: from, value: from_bal - amount)
            store.balances.set(key: to, value: store.balances.get(key: to) + amount)
            emit_transfer(from: from, to: to, value: amount)
            return true
        }
    }

    recv Erc20Extended {
        Mint { to, amount } -> bool uses (mut store, mut log) {
            store.total_supply += amount
            store.balances.set(key: to, value: store.balances.get(key: to) + amount)
            emit_transfer(from: Address::zero(), to: to, value: amount)
            return true
        }
    }
}

fn emit_transfer(from: Address, to: Address, value: u256) uses (log: mut Log) {
    log.emit(Transfer { from, to, value })
}

fn emit_approval(owner: Address, spender: Address, value: u256)
uses (log: mut Log)
{
    log.emit(Approval { owner, spender, value })
}

#[event]
struct Transfer {
    #[indexed]
    from: Address,
    #[indexed]
    to: Address,
    value: u256,
}

#[event]
struct Approval {
    #[indexed]
    owner: Address,
    #[indexed]
    spender: Address,
    value: u256,
}

/// Helper contract used by tests to simulate multiple ERC20 callers.
msg TokenUserMsg {
    #[selector = 0x10]
    ProxyTransfer { token: Address, to: Address, amount: u256 } -> bool,
    #[selector = 0x11]
    ProxyApprove { token: Address, spender: Address, amount: u256 } -> bool,
    #[selector = 0x12]
    ProxyTransferFrom { token: Address, from: Address, to: Address, amount: u256 } -> bool,
}

pub contract TokenUser uses (call: mut Call) {
    recv TokenUserMsg {
        ProxyTransfer { token, to, amount } -> bool
        uses (mut call)
        {
            call.call(
                addr: token,
                gas: 100000,
                value: 0,
                message: Erc20::Transfer { to, amount },
            )
        }

        ProxyApprove { token, spender, amount } -> bool
        uses (mut call)
        {
            call.call(
                addr: token,
                gas: 100000,
                value: 0,
                message: Erc20::Approve { spender, amount },
            )
        }

        ProxyTransferFrom { token, from, to, amount } -> bool
        uses (mut call)
        {
            call.call(
                addr: token,
                gas: 100000,
                value: 0,
                message: Erc20::TransferFrom { from, to, amount },
            )
        }
    }
}

#[test]
fn test_cool_coin_erc20_happy_path() uses (evm: mut Evm) {
    let alice = evm.create2<TokenUser>(value: 0, args: (), salt: 0)
    let bob = evm.create2<TokenUser>(value: 0, args: (), salt: 1)
    assert(alice.inner != 0)
    assert(bob.inner != 0)

    let initial_supply: u256 = 1000
    let token = evm.create2<CoolCoin>(value: 0, args: (initial_supply, alice), salt: 2)
    assert(token.inner != 0)

    // Metadata
    let name: u256 = evm.call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Name {},
        )
    assert(name == 0x436f6f6c436f696e)
    let symbol: u256 = evm.call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Symbol {},
        )
    assert(symbol == 0x434f4f4c)
    let decimals: u8 = evm.call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Decimals {},
        )
    assert(decimals == 18)

    // Initial supply goes to the constructor `owner` address.
    let total: u256 = evm.call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::TotalSupply {},
        )
    assert(total == initial_supply)
    let bal_alice: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: alice },
        )
    assert(bal_alice == initial_supply)
    let bal_bob: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: bob },
        )
    assert(bal_bob == 0)

    // Alice transfers to Bob.
    let ok: bool = evm
        .call(
            addr: alice,
            gas: 200000,
            value: 0,
            message: TokenUserMsg::ProxyTransfer { token, to: bob, amount: 250 },
        )
    assert(ok == true)

    let bal_alice: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: alice },
        )
    assert(bal_alice == 750)
    let bal_bob: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: bob },
        )
    assert(bal_bob == 250)

    // Alice approves Bob.
    let ok: bool = evm
        .call(
            addr: alice,
            gas: 200000,
            value: 0,
            message: TokenUserMsg::ProxyApprove { token, spender: bob, amount: 100 },
        )
    assert(ok == true)

    let allow: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Allowance { owner: alice, spender: bob },
        )
    assert(allow == 100)

    // Bob spends some of Alice's tokens via transferFrom.
    let ok: bool = evm
        .call(
            addr: bob,
            gas: 200000,
            value: 0,
            message: TokenUserMsg::ProxyTransferFrom { token, from: alice, to: bob, amount: 60 },
        )
    assert(ok == true)

    let bal_alice: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: alice },
        )
    assert(bal_alice == 690)
    let bal_bob: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: bob },
        )
    assert(bal_bob == 310)
    let allow: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Allowance { owner: alice, spender: bob },
        )
    assert(allow == 40)

    // Exceeding allowance fails (no state changes).
    let ok: bool = evm
        .call(
            addr: bob,
            gas: 200000,
            value: 0,
            message: TokenUserMsg::ProxyTransferFrom { token, from: alice, to: bob, amount: 50 },
        )
    assert(ok == false)

    let bal_alice: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: alice },
        )
    assert(bal_alice == 690)
    let bal_bob: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: bob },
        )
    assert(bal_bob == 310)
    let allow: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::Allowance { owner: alice, spender: bob },
        )
    assert(allow == 40)

    // Exceeding balance fails.
    let ok: bool = evm
        .call(
            addr: alice,
            gas: 200000,
            value: 0,
            message: TokenUserMsg::ProxyTransfer { token, to: bob, amount: 1000000 },
        )
    assert(ok == false)

    // Mint increases total supply and recipient balance.
    let ok: bool = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20Extended::Mint { to: bob, amount: 500 },
        )
    assert(ok == true)

    let total: u256 = evm.call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::TotalSupply {},
        )
    assert(total == 1500)
    let bal_bob: u256 = evm
        .call(
            addr: token,
            gas: 100000,
            value: 0,
            message: Erc20::BalanceOf { account: bob },
        )
    assert(bal_bob == 810)
}
